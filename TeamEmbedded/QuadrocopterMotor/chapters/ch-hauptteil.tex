\chapter{Realisierung}
\label{sec:real}

Die Hardware kann bei Bedarf in einem abschlie�barem Container gelagert werden und nach Absprache mit Projektteilnehmer und Projektleiter die Hardware auch mitgenommen werden. 

\section{Inbetriebnahme der Hardware}
\label{Inbetriebname}
Eine MicroSD-Karte mit aufgespieltem Ubuntu-Image muss in den Raspberry Pi Kartenslot gesteckt werden.

Als Versorgungsspannung ben�tigt der Quadrocopter 11.7 Volt mit Akku oder 10V-11V mit Netzger�t. Beim Umlegen des Hauptschalters sollen die LED�s am Quadrocopter und PI blinken sowie die Motoren einen Impuls erhalten.

Beim Motorentests sollte der Quadrocopter befestigt werden, damit dieser nicht besch�digt wird geht. Im EZS-Labor wurde hierf�r an einem Arbeitsplatz ein Schraubstock montiert.

Der I2C-Bus (braunes rot/blaues Kabel) wird mit den I2C Pins des Raspberry PI B+ verbunden. Pin2 ist Serial Data und Pin5 ist Serial Clock. Braun-blaues Kabel ist f�r das Clocksignal , braun-rotes Kabel ist f�r das Datensignal. Testen kann man die I2C Configuration des PI mit dem Befehl:

sudo i2cdetect -y 1

In der nachfolgenden Tabelle finden sich alle beinhalteten Komponenten des I2C1-Buses wieder.
\begin{table}[H]
	\begin{center}
		\begin{tabular}{| l | p{3cm} | |p{5cm}|}
			\hline
			Typ & I2C Adresse 7bit  & Information \\
			\hline
			ADC & 0x49 & ADDR <-> VDD\\
			\hline
			Beschleunigungssensor  \newline  Magnetometer & 0x1E  & SA0 <-> GND  \\
			\hline 
			Barometer & 0x5C & SA0 <-> GND \\
			\hline 
			Gyrometer & 0x6A & SA0 <-> GND\\
			\hline
			Brushless Motoren Treiber 1-4  &0x29,0x2A, 0x2B,0x2C& Je nach HElicopter Typ unterschiedlich, I2C Adressen sind per HW festgelegt , per Software nicht �nderbar\\
			\hline 
			Brushless Motoren Treiber 5-8  & 0x5A,0x5C, 0x5E,0x60& Nicht getestet, zu �berpr�fen und ggf. zu �berarbeiten in der \textit{MOTOR.h}\\
			\hline
			Laser Sensor & 0x62 & Standardadresse des Herstellers\\
			\hline
		\end{tabular}
	\end{center}
	\caption{I2C Adsressvergabe}
\end{table}




\paragraph{Der Remoteempf�nger GR-16} hat drei Verbindungen zum Raspberry Pi:
Eine 3,6V bis 8,4V Spannungsversorgung, Ground und eine Datenverbindung.
\phantomsection
\label{Receiver}
\begin{figure}[H]
	\centering
	\includegraphics{fig/GR-16.png}
	\caption[GR-16 Verkabelung]{GR-16 Verkabelung\protect\footnotemark}
\end{figure}
\footnotetext{http://www.graupner.de/mediaroot/files/33508\_Kurzanleitung\_de.pdf}
Die Spannung und Ground kann direkt �ber das Raspberry Pi bezogen werden. F�r die Daten muss einer der GPIO Pins als Input deklariert werden.

Um die Fernbedienung mx-20 mit dem Empf�nger GR-16 zu verbinden m�ssen beide Ger�te eingeschaltet sein (Empf�nger LED blinkt Rot). Beim Anschalten der Fernbedienung wird gefragt ob \emph{HF} EIN oder AUS ist. Stellen Sie auf AUS und best�tigen Sie mit Dr�cken der Set-Taste. Dr�cken sie erneut Set um in die Einstellungen zu gelangen. Scrollen Sie sich mit den Pfeiltasten durch das Men� bis Sie das Men� \emph{Grundeinstellungen Mod.} sehen. �ffnen Sie mit Set das Men� und scrollen Sie durch bis zu Punkt \emph{Modul}. Best�tigen Sie noch NICHT mit der Set-Taste. 
Halten Sie nun am Empf�nger solange die Set Taste gedr�ckt, bis sich zur der roten LED noch eine gr�ne LED einschaltet. Bet�tigen Sie jetzt den Set-Taster auf der Fernbedienung. Es sollte der Info-Text \emph{Binden ...} angezeigt werden.
Wenn die Verbindung erfolgreich durchgef�hrt wurde leuchtet die LED dauerhaft gr�n. \cite{doc:gt-16}

\newpage

\section{Debuggen der Programme}

\paragraph{Target laden}
Rechtsklick auf Projekt Ordner, \newline
Build Configurations -> Set Active -> Target.\newline
Rechtsklick auf Projekt Ordner, Build Project.

Debug Pfeil anklicken und helicopter-raspberry target ausw�hlen.

Oder �ber das Terminal: In das Verzeichnis \emph{helikopter-raspberry/impl/trunk/} wechseln
und mit dem Befehl \newline
\emph{make MAKECMDGOALS=target}\newline
das Programm  kompilieren und automatisch auf das Raspberry Pi laden.

\paragraph{Host laden}
Rechtsklick auf Projekt Ordner, 
Build Configurations -> Set Active -> Host.
Rechtsklick auf Projekt Ordner, Build Project.

Debug Pfeil anklicken und READ-UDP ausw�hlen.

\paragraph{Programme laufen lassen}
In die Debug-Ansicht von Eclipse wechseln (oben rechts). In dem Debug-Fenster sollten nun eine Remote-Anwendung (Anwendung auf Pi) und eine Host-Anwendung gestartet sein. Um diese laufen zu lassen muss der jeweilige Prozess ausgew�hlt werden und auf Resume geklickt werden sowie ggf. Breakpoints entfernt werden.

Nachdem die beiden Programme laufen muss noch der zu startende Testfall ausgew�hlt werden. Dies geschieht, in dem man �ber die Console die jeweiligen Testfall ausw�hlt, z.B. "testmatlabimu". Das im Grundlagenteil Udp-Programm ist hier als Testfall eingef�gt und kann mit der Eingabe "testudp" gestartet werden.

Nun laufen die Programme. Falls im ausgew�hlten Testfall Ausgaben vorhanden sind, sind diese in der Console zu sehen.

\paragraph{Beenden der Applicationen}
Um Probleme zu vermeiden ist es wichtig, die laufenden Programme immer manuell anzuhalten und zu \emph{killen}. Dies gelingt, in dem man in der Debug-Ansicht auf das zu beendene Programm rechtsklickt und auf Terminate klickt. 

\paragraph{Testf�lle}
In der main.c wird in dem definiertem \emph{enum} enumTestCases ein neuer Testfall angelegt.
In der int main(){...} wird bei Start auf eine Eingabe des zu startenden Testfalles gewartet. Hier muss noch ein \emph{else if}-Anweisung erg�nzt werden. 
In der Variable runCommand wird der Name des abzuarbeitenden Testfalles abgespeichert.
In der nachfolgenden \emph{Switch}-Anweisung steht der eigentliche Code, welcher bei Auswahl dieses Testfalles ausgef�hrt wird.

\newpage
\section{Umstellung auf eine automatische dynamische Testumgebung}

Die Main-Funktion zum Testen soll umstrukturiert werden, da die vorherige Struktur recht umst�ndlich zu testen und zu bedienen war. Es muss vor jedem einzelnen Testfall das Programm komplett auf das Raspberry �bertragen werden und �ber die Remote-Verbindung der zu startende Testfall h�ndisch ausgew�hlt werden. Dieser wird ausgef�hrt und das Programm ist beendet, sobald der Testfall beendet ist. Um einen weiteren Test zu starten musste wieder eine Remote-Verbindung aufgebaut werden. Dies funktioniert, ist aber nicht die optimale L�sung.

Stattdessen soll die neue Main-Funktion �ber eine Dauerschleife verf�gen, in dieser ein Textfile ausgelesen wird. Dieses File beinhaltet die zu startenden Testcases des Programmes.

In diesem Textfile werden alle Testf�lle festgehalten, mit einem Status ob dieser laufen soll oder nicht. Der Status soll w�hrend der Laufzeit des Programmes �nderbar sein und dieses auch nicht unterbrechen.

Dieses Textfile sieht folgenderma�en aus:

...\\
testmotorpwm=1\\
testmotorisr=1\\
testmotortxt=0\\
....\\

Dies bedeutet: die Testf�lle testmotorpwm und testmotorisr sollen gestartet werden, testmotortxt soll nicht gestartet werden.
Der Testfall testmotorpwm wird zuerst ausgelesen und von der Main-Funktion auf Null zur�ckgesetzt. Anschlie�end l�uft der Testfall ab.

W�hrenddessen wird der Testfall testmotortxt aktiviert. 

...\\
testmotorpwm=0\\
testmotorisr=1\\
testmotortxt=1\\
....

Ist der Testfall beendet wird das Textfile erneut eingelesen und der n�chste gesetzte Testfall wird gestartet.

\newpage
\paragraph{Umstrukturierung der main.c:}

Es wurde eine Endlosschleife eingef�gt. Statt auf eine Tastatureingabe �ber eine Konsole zu warten, wird in dieser alle zwei Sekunden das \textit{\_Testfile} ausgelesen und �berpr�ft, ob ein Testfall ausgef�hrt werden soll.


In allen Testf�llen darf keine Endlosschleife vorhanden sein, bzw. muss in weiteren Endlosschleifen ein Abbruchkriterium festgelegt sein. In den meisten F�llen kann der Testfall mit Dr�cken der Taste \textit{p} abgebrochen werden. In Testf�llen, in denen ein Testfile ausgelesen wird, wird bei Erreichen des Dateiendes der Testfall beendet und gelangt so wieder in die Hauptschleife zur�ck.

\paragraph{Script zum Setzen der Testf�lle:}

Zum Setzen oder L�schen eines Testfiles wurde ein Script geschrieben, welches auf das textfile \textit{\_Testfile} zugreift und die Eintr�ge je nach Eingabe �berarbeitet.

Verwendet wird das Script folgenderma�en:

\begin{lstlisting}[language=bash]
.\testcase NameTestfall [Modus]
\end{lstlisting}
 	 
Als ersten Parameter ist der zu �berarbeitende Testfall anzugeben.\\
Der Modus ist ein optionaler Parameter. Ist dieser Parameter nicht vorhanden, wird automatisch \emph{set} angenommen. \textit{set} markiert den Testfall als abzuarbeiten, \textit{clear} l�scht diese Markierung wiederrum. Das Script zeigt keinen Fehler oder Warnung auf, wenn der testcase nicht gelistet ist.

Der Quellcode ist im Kapitel \ref{script_testcase} \nameref{script_testcase} auf S.\pageref{script_testcase} einzusehen.

\newpage
\section{Valedierung der empfangenen Werte}
\label{sec:real-unter}
Im testcase testmatlabimu stimmen die empfangenen und gesendeten Werte nicht �berein. Hier ist der Fehler zu finden und zu beheben.

Es werden insgesamt 11 double Values von den diversen Sensoren an den Host gesendet. Die Kalkulation der Werte ist richtig, kommen jedoch beim Empf�nger falsch an. Dieses Fehlverhalten gilt es zu untersuchen.

Hierf�r wurde ein neuer Testfall angelegt, alle 11 Double Werte per UDP versendet und diese auf beiden Seiten ausgegeben. 

Nach dem Setzen der Breakpoints, so das nur einmal die Werte gesendet werden, erhalten wir folgende Ausgaben auf der Console:

\begin{multicols}{2}
	 \begin{lstlisting}[language=C++]
	 Starting read over UDP
	 /home/ezs/git/helikopter- raspberry/impl/trunk/host /READ-UDP.elf: Wartet auf Daten am Port (UDP) 5000
	 Acc X 0.000000 
	 Acc Y 0.910135 
	 Acc Z -0.488599 
	 Mag X -10.533617 
	 Mag Y 0.000024 
	 Mag Z 0.000021 
	 Gyro yaw 0.000014 
	 Gyro pitch -0.473037 nGyro roll 0.473037 
	 Temp -0.396741 
	 Press 31.825000 
	 \end{lstlisting}
	
	\columnbreak
	
	 \begin{lstlisting}[language=C++]
	 Received string is testallsensordata 
	 Starting IMU Matlab Test
	 
	 
	 Acc X 0.910135 
	 Acc Y -0.488599 
	 Acc Z -10.533617 
	 Mag X 0.000024 
	 Mag Y 0.000021 
	 Mag Z 0.000014 
	 Gyro yaw -0.473037 
	 Gyro pitch 0.473037 
	 Gyro roll -0.396741 
	 Temp 31.825000 
	 Press 987.931396 
	 \end{lstlisting}
\end{multicols}
 

Nach einem Vergleich f�llt auf, dass beim Empfang der Daten sich bei X-Wert vom Acc eine Null eingef�gt hat. Ansonsten scheinen die Daten zu stimmen. Die Daten sind nur um eins versetzt.

In der read-udp-host.c werden die Werte in der Variable \emph{l\_recvImuState\_st} gespeichert. Beim Betrachten der Inhalte dieser Variablen ist zu erkennen, dass diese in \emph{acc.f64} einen Wert hat der Circa null entspricht, die restlichen Werte sehen richtig aus, nur weiterhin um einen Wert verschoben.

Verdacht: Beim Senden der Daten wird auch noch ein Zeitstempel dieses Telegramms mitgesendet: 
\begin{lstlisting}[language=C++]
//time.h
struct timespec{
	__time_t tv_sec; /* Seconds */
	__syscall_slong_t tv_ns	/* Seconds */
	};

//udpImuLib.c
struct timespec l_timespec_st;

\end{lstlisting}

Diese Daten haben die L�nge von 8 Byte (beide vom Typ long int). Diese Daten werden mit den Sensordaten gesendet. Die Paketl�nge nimmt zu.
Da auf der Empf�ngerseite die Empfangsstruktur aber diesen timestamp nicht erwartet, geht er davon aus, dass der erste Wert, den er bekommt, f�r den Acc X Sensor-Wert steht.
Aus diesem Grund verrutschen die restlichen Daten um eins ab und der erste Sensor-Wert ist falsch da dieser den Timestamp widerspiegelt.

\paragraph{Problembehebung}
Die fehlenden Daten m�ssen in dem Struct bekannt gemacht werden, sodass die L�nge der beiden Felder nun gleich Gro� sind (96 Byte).
Hierf�r musste das Struct \emph{halImu\_orientationValues} im imu.h um einen Datentyp struct timespec erweitert werden sowie die notwendige Standardlibary \emph{time.h} hinzugef�gt werden.
Dann wurde die Testausgabe um den Timestamp erweitert.
Die Werte stimmen nun �berein:
\begin{multicols}{2}
	\begin{lstlisting}[language=C++]
	Starting read over UDP
	/home/ezs/git/helikopter -raspberry/impl/trunk/host /READ-UDP.elf: Wartet auf Daten am Port (UDP) 5000
	Time  1434105267.000000000 
	Acc X 0.792776 
	Acc Y -0.555661 
	Acc Z -10.581519 
	Mag X 0.000024 
	Mag Y 0.000021 
	Mag Z 0.000014 
	Gyro yaw -0.228889 
	Gyro pitch -0.122074 
	Gyro roll -0.488296 
	Temp 32.056250 
	Press 987.923828 
	\end{lstlisting}
	\columnbreak
	\begin{lstlisting}[language=C++]
	 Received string is testallsensordata 
		Starting IMU Matlab Test
		 
	
	
	Acc X 0.792776 
	Acc Y -0.555661 
	Acc Z -10.581519 
	Mag X 0.000024 
	Mag Y 0.000021 
	Mag Z 0.000014 
	Gyro yaw -0.228889 
	Gyro pitch -0.122074 
	Gyro roll -0.488296 
	Temp 32.056250 
	Press 987.923828 
	\end{lstlisting}
\end{multicols}

\begin{lstlisting}[language=C++]
#include <time.h>
typedef struct{
	struct timespec l_timestamp_st;
	halAccmag_3dDoubleVector acc;
	halAccmag_3dDoubleVector mag;
	strGyro gyro;
	double temperature_f64;
	double pressure_f64;
} halImu_orientationValues;

\end{lstlisting}

\section{Software Motortreiber}

Es soll Software f�r den Hardware-Treiber, der die Motoren ansteuert, geschrieben werden. Zun�chst muss der Raspberry Pi mit dem I2C-Bus verbunden werden. 
Die I2C Adressen der Motoren sind in der Motor.h hinterlegt. F�r die Quadrocopter wurden die Werte definiert. Die Werte des Octocopter m�ssen zun�chst �berpr�ft werden.

Mittels des Befehl:

\begin{center}
	i2cdetect -y 1
\end{center}

k�nnen die vergebenen Adressen im Bussystem angezeigt und validiert werden.

Die Daten, die von dem Hardware Brushless-Controller erwartet werden, besitzen folgendes Format:

	\begin{table}[H]
		\centering
		\begin{tabular}{|c|c|}
			\hline
			I2C Adresse [1 Byte] & PWM Value [1 Byte]\\ \hline
		\end{tabular}
	\caption{I2C Frame Brushless Motoren Treiber}
	\end{table}

Mit Hilfe des Befehls 

\begin{center}
	i2cset -y 1 0x29 0x55
\end{center}

wird an den Controller mit der I2C Adresse 0x29 ( Motor Nr.1) der Wert 0x55 gesendet.

\subsection{Verwendung des Software-Treibers}

In der main.h muss zun�chst definiert werden, auf welchem Typ von den HElicoptern das Programm geladen werden soll.
\begin{lstlisting}[language=C++]
#include <time.h>
#define Quadro_Plus 1
//#define Quadro_X 1
//#define Okto_Plus 1
\end{lstlisting}

Anschlie�end sollte baldm�glichst die InitMotor() aufgerufen werden, die unter anderem einen Timer initialisiert und startet. Bei Ablauf des Timers wird ein Flag gesetzt. Dieses Flag muss im Quellcode mit der Funktion \emph{GetFlagRunSendPwmToMotor()} abgefragt werden. Wenn dieses Flag gesetzt ist, muss die Funktion \emph{sendPwmToMotor()} aufgerufen werden.

\begin{lstlisting}[language=C++]
...
InitMotor();
...
while(1){
...
if(GetFlagRunSendPwmToMotor() == 1){
sendPwmToMotor();
}
...

}
\end{lstlisting}
Der aktuelle PWM-Wert eines Motors kann mittels der Funktion \emph{GetPwmMotor(...)} zur�ckgegeben werden.

\begin{lstlisting}[language=C++]
value = GetPwmMotor(6);
value > 0? value--: (value=DEFMotorSetpointMIN);
SetPwmMotor(DEFMotorNo7_PWM, value ,0);
\end{lstlisting}

Wichtig: Alle ISR sollen knapp gehalten werden, da ansonsten die Motoren nicht mehr angesprochen werden k�nnen.

Mit der Funktion \emph{SetPwmMotor(...)} k�nnen die PWM-Werte, die  per I2C gesendet werden, �berschrieben werden. Optional kann ein Flag gesetzt werden. Ist dies der Fall wird anschlie�end die Funktion \emph{sendPwmToMotor()} aufgerufen.

\subsection{Headerfile}

Hier sind die verschiedenen HElicopter Varianten sowie deren definierte Eigenschaften (Anzahl Motoren, Drehrichtung der Motoren, Motorenreihenfogen) festgehalten.

F�r weitere Informationen (wie z.B. Namen der defines) siehe in Kapitel \ref{motorH} in  \nameref{motorH} auf S.\pageref{motorH} .

\subsection{Funktionen}

Beschreibung der Funktionen befinden sich in den jeweiligen dar�ber liegenden Kommentaren mit Parametern und Return Values.

Auf alle globalen Variablen/Flags werden mit Funktionen zugegriffen. Ein direkter Zugriff ist zu vermeiden.

\begin{lstlisting}[language=C++,firstnumber=14]
/* Global Variables */
char BLCtrlADRExecuteOrder[DEFMotorsCount];
char PWMValue[DEFMotorsCount];

//Flags
char flagRunSendPwmToMotor;
\end{lstlisting}

\begin{lstlisting}[language=C++,firstnumber=21]
/*!***************************************************************
* \author Chris M�nch( chmoit00 )
*
* \brief calls init functions which needed for the motor driver:
* SetFlagRunSendPwmToMotor(0);
*	SetMotorExecutionOrder();
*	SetPwmMotor(DEFMotorALL_PWM, DEFMotorSetpointMIN, 0);
*	Last one always initMotorTimer()
*	InitMotorTimer(microSeconds);
*	SetFlagRunSendPwmToMotor(1);
*
* \param[ in ] microSeconds - Time in uS when Timer expired.
*
* \internal
* CHANGELOG:
*
* \endinternal
*****************************************************************/
void InitMotor(int microSeconds){
	SetFlagRunSendPwmToMotor(0);
	SetMotorExecutionOrder();
	SetPwmMotor(DEFMotorALL_PWM, DEFMotorSetpointMIN, 0);
	//Last one always initMotorTimer()
	InitMotorTimer(microSeconds);
	SetFlagRunSendPwmToMotor(1);
}
\end{lstlisting}

\begin{lstlisting}[language=C++,firstnumber=48]
/*!***************************************************************
* \author Chris M�nch( chmoit00 )
* \date 2016/01/08
*
* \brief set Motor Exectution Order
*
* \internal
* CHANGELOG:
*
* \endinternal
*****************************************************************/
void SetMotorExecutionOrder(){
	GetBLCtrlADRExecuteOrder(&BLCtrlADRExecuteOrder[0]);
}
\end{lstlisting}

\begin{lstlisting}[language=C++,firstnumber=63]
/*!***************************************************************
* \author Chris M�nch( chmoit00 )
* \date 2016/01/08
*
* \brief sets PWM Signal of selected Motor to pwmValue
* \details toSet = 00001111 sets the first 4 Motors in Execution Order to pwmValue
*
* \param[ in ] toSet - Which Motor to Set
* \param[ in ] pwmValue - Which Value so Set
* \param[ in ] forceSend - optional Parameter if !0 flagRunSendPwmToMotor will be set
*
* \internal
* CHANGELOG:
*
* \endinternal
*****************************************************************/
void SetPwmMotor(char toSet , int pwmValue, int forceSend){
	int i=0;
	pwmValue = pwmValue >= DEFMotorSetpointMIN ? pwmValue :  DEFMotorSetpointMIN;
	pwmValue = pwmValue <= DEFMotorSetpointMAX ?  pwmValue :  DEFMotorSetpointMAX;
	while(toSet != 0 && i < DEFMotorsCount){
	
		if(toSet%2){
			PWMValue[i]= pwmValue;
		}
		toSet= toSet >>1;
		i++;
	}
	if(forceSend != 0){
		SetFlagRunSendPwmToMotor(1);
	}
}
\end{lstlisting}

\begin{lstlisting}[language=C++,firstnumber=96]
/*!***************************************************************
* \author Chris M�nch( chmoit00 )
* \date 2016/01/08
*
* \brief adds to the current PWM Signal of selected Motor the pwmValue
* \details toSet = 00001111 add to the first 4 motors pwmValue
*
* \param[ in ] toSet - Which Motor to Set
* \param[ in ] pwmValue - adding pwm value to current PWMValue
* \param[ in ] forceSend - optional Parameter if !0 flagRunSendPwmToMotor will be set
*
* \internal
* CHANGELOG:
*
* \endinternal
*****************************************************************/
void AddPwmMotor(char toSet , int pwmValue, int forceSend){
	int i=0;
	
	while(toSet != 0 && i < DEFMotorsCount){
	
		if(toSet%2){
			pwmValue = pwmValue+GetPwmMotor(i);
			pwmValue = pwmValue >= DEFMotorSetpointMIN ? pwmValue :  DEFMotorSetpointMIN;
			pwmValue = pwmValue <= DEFMotorSetpointMAX ?  pwmValue :  DEFMotorSetpointMAX;
			PWMValue[i]= pwmValue;
		}
		toSet= toSet >>1;
		i++;
	}
	if(forceSend != 0){
		SetFlagRunSendPwmToMotor(1);
	}
}

\end{lstlisting}

\begin{lstlisting}[language=C++,firstnumber=131]
/*!***************************************************************
* \author Chris M�nch( chmoit00 )
* \date 2016/01/08
*
* \brief Subtract to the current PWM Signal of selected Motor the pwmValue
* \details toSet = 00001111 subtract to the first 4 motors pwmValue
*
* \param[ in ] toSet - Which Motor to Set
* \param[ in ] pwmValue - pwm value to subtract from Current PWMValue
* \param[ in ] forceSend - optional Parameter if !0 flagRunSendPwmToMotor will be set
*
* \internal
* CHANGELOG:
*
* \endinternal
*****************************************************************/
void SubbPwmMotor(char toSet , int pwmValue, int forceSend){
	int i=0;
	
	while(toSet != 0 && i < DEFMotorsCount){
	
		if(toSet%2){
			pwmValue = GetPwmMotor(i)- pwmValue;
			pwmValue = pwmValue >= DEFMotorSetpointMIN ? pwmValue :  DEFMotorSetpointMIN;
			pwmValue = pwmValue <= DEFMotorSetpointMAX ?  pwmValue :  DEFMotorSetpointMAX;
			PWMValue[i]= pwmValue;
		}
		toSet= toSet >>1;
		i++;
		}
	if(forceSend != 0){
		SetFlagRunSendPwmToMotor(1);
	}
}
\end{lstlisting}

\begin{lstlisting}[language=C++,firstnumber=167]
/*!***************************************************************
* \author Chris M�nch( chmoit00 )
* \date 2016/01/08
*
* \brief Gets pwmValue from a specific motor
* \details
*
* \param[ in ] motorNumber - which motor
*
* \param[ out ] pwmValue of the chosen Motor, returns O if chosen Motor not exist in these HElicoptertype
* 
* \internal
* CHANGELOG:
*
* \endinternal
*****************************************************************/
int GetPwmMotor(int motorNumber){
	return motorNumber < DEFMotorsCount ? PWMValue[motorNumber]: 0;
}
\end{lstlisting}

\begin{lstlisting}[language=C++,firstnumber=188]
/*!***************************************************************
* \author Chris M�nch( chmoit00 )
* \date 2016/01/08
*
* \brief init Timer for the IsrMotor
* \details
*
* \param[ in ] microSeconds - Time in uS when Timer expired.
*
* \internal
* CHANGELOG:
*
* \endinternal
*****************************************************************/
void InitMotorTimer(int microSeconds){

	struct sigaction sa;
	struct itimerval timer;
	
	//Creates Signal, if signal Rising a_handler called
	memset(&sa, 0 , sizeof(sa));
	sa.sa_handler = &IsrSetFlag;
	sigaction(SIGVTALRM, &sa, NULL);
	
	//Expire the Timer after:
	timer.it_value.tv_sec = 0;
	timer.it_value.tv_usec = 0;
	//And every ... after that:
	timer.it_interval.tv_sec = 0;
	timer.it_interval.tv_usec = microSeconds;
	//upon expiration the signal SIGVTALRM raised
	setitimer(ITIMER_VIRTUAL, &timer , NULL);
}
\end{lstlisting}

\begin{lstlisting}[language=C++,firstnumber=222]
/*!***************************************************************
* \author Chris M�nch( chmoit00 )
* \date 2016/01/08
*
* \brief set flag flagRunSendPwmToMotor
*
* \param[ in ] 1 Set Flag, else clear Flag
*
* \internal
* CHANGELOG:
*
* \endinternal
*****************************************************************/
void SetFlagRunSendPwmToMotor(char value){
	if(value == 1){
		flagRunSendPwmToMotor=value;
	}else{
		flagRunSendPwmToMotor=0;
	}
}
\end{lstlisting}

\begin{lstlisting}[language=C++,firstnumber=243]
/*!***************************************************************
* \author Chris M�nch( chmoit00 )
* \date 2016/01/08
*
* \brief ISR for set flag as flagRunSendPwmToMotor
*
* \internal
* CHANGELOG:
*
* \endinternal
*****************************************************************/
void IsrSetFlag(){
	flagRunSendPwmToMotor=1;
}
\end{lstlisting}

\begin{lstlisting}[language=C++,firstnumber=258]
/*!***************************************************************
* \author Chris M�nch( chmoit00 )
* \date 2016/01/08
*
* \brief get flag flagRunSendPwmToMotor
*
* \param[out] flag flagRunSendPwmToMotor
*
* \internal
* CHANGELOG:
*
* \endinternal
*****************************************************************/
char GetFlagRunSendPwmToMotor(){
	return flagRunSendPwmToMotor;
}
\end{lstlisting}

\begin{lstlisting}[language=C++,firstnumber=275]
/*!***************************************************************
* \author Chris M�nch( chmoit00 )
* \date 2016/01/08
*
* \brief sends every timer interrupt to the motors the specific pwm values
*
* \internal
* CHANGELOG:
*
* \endinternal
*****************************************************************/
void sendPwmToMotor(){
	int i;
	for(i = 0; i < DEFMotorsCount ;i++)
	{
		g_lldI2c_WriteI2c_bl(BLCtrlADRExecuteOrder[i],&PWMValue[i],1);
	}
}
\end{lstlisting}

\begin{lstlisting}[language=C++,firstnumber=294]
/*!***************************************************************
* \author Chris M�nch( chmoit00 )
* \date 2016/01/08
*
* \brief Get the I2C addresses orderd by execution (defined in MOTOR.h)
* \details
*
* \param[ in ] Array where the I2C Addresses will be stored
*
* \internal
* CHANGELOG:
*
* \endinternal
*****************************************************************/
void GetBLCtrlADRExecuteOrder(char BLCtrlADRExecuteOrder[]){
#if defined(Quadro_X) || defined(Quadro_Plus)
int BLCTRLADR[4] = {DEFMotorNo1_BLCtrlADR, DEFMotorNo2_BLCtrlADR, DEFMotorNo3_BLCtrlADR, DEFMotorNo4_BLCtrlADR};

BLCtrlADRExecuteOrder[DEFMotorNo1_OrderIDX ]=BLCTRLADR[0];
BLCtrlADRExecuteOrder[DEFMotorNo2_OrderIDX]=BLCTRLADR[1];
BLCtrlADRExecuteOrder[DEFMotorNo3_OrderIDX]=BLCTRLADR[2];
BLCtrlADRExecuteOrder[DEFMotorNo4_OrderIDX]=BLCTRLADR[3];

#endif

#ifdef Okto_Plus
int BLCTRLADR[8] = {DEFMotorNo1_BLCtrlADR, DEFMotorNo2_BLCtrlADR, DEFMotorNo3_BLCtrlADR
DEFMotorNo4_BLCtrlADR, DEFMotorNo5_BLCtrlADR, DEFMotorNo6_BLCtrlADR,
DEFMotorNo7_BLCtrlADR, DEFMotorNo8_BLCtrlADR};

BLCtrlADRExecuteOrder[DEFMotorNo1_OrderIDX]=BLCTRLADR[0];
BLCtrlADRExecuteOrder[DEFMotorNo2_OrderIDX]=BLCTRLADR[1];
BLCtrlADRExecuteOrder[DEFMotorNo3_OrderIDX]=BLCTRLADR[2];
BLCtrlADRExecuteOrder[DEFMotorNo4_OrderIDX]=BLCTRLADR[3];
BLCtrlADRExecuteOrder[DEFMotorNo5_OrderIDX]=BLCTRLADR[4];
BLCtrlADRExecuteOrder[DEFMotorNo6_OrderIDX]=BLCTRLADR[5];
BLCtrlADRExecuteOrder[DEFMotorNo7_OrderIDX]=BLCTRLADR[6];
BLCtrlADRExecuteOrder[DEFMotorNo8_OrderIDX]=BLCTRLADR[7];

#endif
}
\end{lstlisting}

\subsection{Testf�lle}

Um die Funktionalit�t des Treiber zu testen und kontrollieren sind die folgenden Testf�lle geschrieben worden. 

\subparagraph{TESTMOTORPWM}

Dieses Testprogramm sendet alle 10ms an die Motoren einen stets steigenden PWM-Wert bis zum Wert 0x50. Bei erreichen des Wertes wird der PWM-Wert auf den definiertes Minimum gesetzt. Dieser Testfall l�uft ohne ISR ab. Die Daten werden direkt �ber I2C gesendet. Die Schrittweite und das Maximum des Testfalles sind per Konstanten definiert und k�nnen ver�ndert werden. 

\subparagraph{TESTMOTORISR}

Mit diesem Testprogramm wird die ISR-Funktion getestet. Durch Eingabe in der Konsole wie z.B.

+0+0+0+0+7+7+7-8

wird der  PWM-Wert des Motors 0 um vier erh�ht, der Motor 7 um drei erh�ht und der Motor 8 um eins verringert. Die Eingabe ist nicht blockierend. Zum Starten des Testfalls muss ein '+' eingetippt werden.

\subparagraph{TESTMOTORTXT}

Der letzte Testfall liest aus einem Textfile, das sich auf dem Raspberry unter dem Pfad \emph{/home/pi/MotorTest.txt} befinden muss, Zeile f�r Zeile aus und setzt die PWM-Werte so, wie sie in der Zeile angegeben sind.

Die Befehlszeile hat folgendes Format:
\newline
\begin{center}
\#MOTORNUMER[+][-][=][PWMWERT]\;DELAY
\end{center}
z.B.
\#0+100;10 \t - \t Der PWM des Motors 0 erh�ht sich um 100. Die n�chste Zeile wird in 10s eingelesen.
\newpage
\section{Help Functions}

\paragraph{Nicht blockierende Eingabe Funktion kbhit}
Diverse Testf�lle h�ngen von einer Tastatur Eingabe ab. Die Standardfunktionen hierf�r sind blockierende Funktionen. Diese d�rfen jedoch nicht verwendet werden, da die Motoren nicht angesteuert werden k�nnen.
Um Tastatureingaben m�glich zu machen, wurde eine Funktion geschrieben, die den Programmablauf nicht blockiert. Als Return-Wert gibt es immer die zuletzt gedr�ckte Taste zur�ck.

Eine Eingabe, die aus mehreren Chars, besteht muss mit mehreren \emph{kbhit()} aufrufen und durch Schleifen oder if-Verzweigung �berpr�ft werden. Die Eingabe wird aus dem Buffer gelesen.


\begin{lstlisting}[language=C++,firstnumber=0]
#include <termios.h>

int kbhit(void)
{
	struct termios term, oterm;
	int fd = 0;
	int c = 0;
	tcgetattr(fd, &oterm);
	memcpy(&term, &oterm, sizeof(term));
	term.c_lflag = term.c_lflag & (!ICANON);
	term.c_cc[VMIN] = 0;
	term.c_cc[VTIME] = 1;
	tcsetattr(fd, TCSANOW, &term);
	c = getchar();
	tcsetattr(fd, TCSANOW, &oterm);
	return c; 
}
\end{lstlisting}
\newpage
\section{Remotecontroller-Treiber}
\label{Controller Treiber}

Um den autonomen Start bzw. Landevorgang des Quadrocopter einzuleiten muss eine Funkverbindung �ber eine Fernbedienung und einen Transmitter eingerichtet werden. Die Daten sind anschlie�end auszuwerten und zu verarbeiten.

Als Fernbedienung von der Firma Graupner dient der \emph{MX-20} und als Receiver der \emph{GR-16}. Der Anschluss des Receivers erfolgt �ber drei Leitungen:
\begin{itemize} 
	\item  Versorgungsspannung:  5Volt (vom Raspberry) 
	\item  Ground (Raspberry)
	\item PPM (Puls-Pause Modulation) (auf einen der GPIO Pins)
\end{itemize}


\paragraph{Verbinden mit Receiver}
Schalten Sie die Fernbedienung ein und schlie�en den Receiver an den Raspberry Pi an [siehe Abschnitt~ \ref{Receiver} auf Seite \pageref{Receiver}]

\paragraph{PPM-Signal} genannt Puls-Pausen-Modulation (oder auch Puls-Position-Modulation) ist ein f�r analoge Werte verwendetes Kodierungsverfahren und wird vor allem in Funkfernsteuerungen verwendet. Der zu kodierende Wert wird in der L�nge des Pausen/Low Signals zwischen zwei Peaks/High Signalen gesendet. Diese Peaks haben stets die gleiche L�nge als auch gleiche Amplitude.\cite{doc:ppm}

Meist besteht ein PPM-Signal aus mehreren Kan�len zu einem Frame zusammengef�gt und  anschlie�end versendet.

F�r die Decodierung des PPM-Signals ist es empfehlen, ein weiteres Board zu integrieren, das die Decodierung  �bernimmt und die Ergebnisse an das Raspberry Pi weiterleitet, da das Signal sehr genau aufgel�st werden muss und die Decodierung �ber einen Interrupt gesteuert werden soll. Bei zu h�ufigen Auftreten des Interrupts w�rde der Helicopter destabilisiert werden. Zur Auswertung m�ssen nur die Raising Edges oder Falling Edges beachtet und der Offset des High-Pegels abgezogen werden.

Um auf ein weiteres Bauteil zu verzichten wurde stattdessen eine Real-Time-Linux-Version auf dem Raspberry Pi installiert, die die Signale im Nanosekundenbereich dekodieren kann.

\newpage
\paragraph{PPM Signal Mitschnitte}
Der Receiver sendet die empfangenen Signale im Format der Pulse-Pausen-Modulation. Mitgeschnittene �bertragungen\protect\footnotemark  mit Beschreibung sind beigef�gt.
\footnotetext{Von Herrn Trybek bereitgestellt}
\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\textwidth]{fig/Controller_Treiber/GraupnerGR16_8_Frame.png}
	\caption[8 Channel Frame]{8 Channel Frame}
\end{figure}

Es gibt zwei M�glichkeiten: ein Frame mit acht Kan�len, bestehend aus neun Peaks und acht Pausensignalen...

\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\textwidth]{fig/Controller_Treiber/GraupnerGR16_12_Frame.png}
	\caption[12 Channel Frame]{12 Channel Frame}
\end{figure}

... oder einen 12 Kan�len Frame, bestehend aus 13 Peaks und 12 Pausensignalen.

\begin{figure}[H]
\centering
\includegraphics[width=0.6\textwidth]{fig/Controller_Treiber/GraupnerGR16_8_ChX_Gap.png}
\caption[Dauer 8 chanel Frame ]{Dauer 8 Chanel Frame}
\end{figure}

Folgend die Anschaung eines Frames mit acht Kan�len mit der Dauer von 504us.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\textwidth]{fig/Controller_Treiber/GraupnerGR16_8_Ch1_Min.png}
	\caption[Minimale Pause zwischen Frames]{Minimale Pause zwischen Frames}
\end{figure}

Zu sehen ist hier der kleinstm�gliche zeitliche Abstand zwischen zwei Frames mit der Dauer von nur 504us.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\textwidth]{fig/Controller_Treiber/GraupnerGR16_8_Ch1_Max.png}
	\caption[Maximale Pause zwischen Frames]{Maximale Pause zwischen Frames}
\end{figure}

Hier ein Ausschnitt mit dem gr��tm�glichen Abstand zwischen zwei Frames mit der Dauer 1,396ms.

\section{Hardware Layout}
F�r die schnelle Durchf�hrung von �nderungen, Erweiterungen oder Anpassungen an der Hardware werden die Leiterplatinen und Schaltpl�ne mittels Tool elektronisch festgehalten. Die dazu m�gliche Software sind: EAGLE oder Fritzing,
die kostenlos oder als eingeschr�nkte Freeversion angeboten werden, aber diversen Einschr�nkungen unterliegen. Beide Tools haben eine Community, die viele Bauteile in Liberias bereitstellt. 

Im direktem Vergleich macht EAGLE einen professionelleren Eindruck und bietet eine Sammlung von Tutorials und Libraries. Aus diesen Gr�nden fiel die Entscheidung auf die EAGLE SOFTWARE. Es sollte aber mit dem Platz m�glichst sparend umgegangen werden, da bei dieser Freeeware die Gr��e und Anzahl der Layouts begrenzt ist.

\subsection{HElicopter Schematic Layout}

Es wurde f�r die schematischen Zeichnungen ein EAGLE Projekt angelegt, dass die schematischen Zeichnungen aller selbst gebauten bzw. zusammengef�gten Bauteile enth�lt. Das Projekt File ist im Verzeichnis \textit{trunk/hardware/} unter \textit{HElicopterPlus} abgespeichert.

Derzeit befinden sich zwei verschiedene schematischen Zeichnungen im Projektverzeichnis, die maximal aus zwei sogenannten Sheets besteht (Begrenzung durch die Freeware-Version von EAGLE). Der erster Sheet beinhaltet immer, denn Komplettaufbau des jeweiligen Systems. Der zweite Sheet wird verwendet um druckbare Versionen das Schaltplans zu erstellen (DINA4 Frame). Hierbei ist es wichtig, eine �bersichtliche Abspaltung vorzunehmen. 


\newpage
\includepdf[landscape=true,pages={1,2}]{fig/Schematic/SchematicKomplettPrintVersion.pdf}
\includepdf[landscape=true]{fig/Schematic/SchematicLedDriver.pdf}

\subsubsection{Richtlinien\cite{doc:guidelinesSchematics}}

\begin{itemize}
	\item Platzierung von mindestens einem Frame in jedem Sheet
	\item Verwendung von "Common" Symbolen
	\item Jedem Bauteil einen Wert zuordnen (wenn m�glich)
	\item F�r Verbindungen ausschlie�lich \textit{Net} verwenden ( nicht \textit{Wire})
	\item Verbindungen oder �berbr�ckungen wie in Abb. \ref{CrossingConnection} dargestellt
	\item Abk�rzungen direkt in dem jeweiligen Sheet festhalten
	\item Name und Bauteile immer in eine Richtung flie�en lassen (wenn m�glich)
	\item �berbr�cken von Netzen m�glichst gering halten
	\item F�r gro�e schematische Skizzen immer auch druckbare Versionen in DINA4 Format erstellen
	\item Wichtigen Netzen immer einen Namen zuordnen (GND, +5V, SDA, SLC, ...)
	\item Namen und Bezeichnungen kurz halten
\end{itemize}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\textwidth]{fig/Schematic/CrossingConnection.jpg}
	\caption[Net verbinden/�berbr�cken]{Net verbinden/�berbr�cken\protect\footnotemark}
	\label{CrossingConnection}
\end{figure}
\footnotetext{\url{http://www.k-state.edu/ksuedl/publications/Technote\%208\%20-\%20Guidelines\%20for\%20Drawing\%20Schematics.pdf}}


\newpage
\subsection{HElicopter Libary}
Auf der Bibliothek von Eagles k�nnen unter der Rubrik \emph{Downloads} Bauteile zu denn Schaltpl�nen gefunden werden. Die dort vorhandenen Bibliotheken sind von Usern bereitgestellt worden. Deshalb besteht die M�glichkeit, dass Bauteile fehlerhaft sind.

Wenn in der Bibliothek kein Element f�r das Bauteil gefunden werden konnte, muss dieses erstellt und in der bereits vorhandene Libary \textit{HElicopterLib.lbr} hinzugef�gt werden. In dieser Libary sind alle Teile festgehalten, die f�r die Quadrocopter ben�tigt werden. 

Ein Bauteil oder auch ein Device besteht aus insgesamt drei eigenen Bestandteilen, die alle vorhanden sein m�ssen, um das Bauteil zu verwenden:
\begin{center}
	\begin{tabular}{l p{10 cm} }
	Symbol & Darunter versteht man eine schematische Skizze eines Bauteils. Alle Schnittstellen des Bauteiles sind zu erkennen und ggf. zu kennzeichen. \newline Der Orignalma�stab und Echtheit der Pinanordnung spielt keine Rolle. Diese soll m�glichst so platziert werden, um im sp�teren Layout eine gewisse �bersichtlichkeit zu wahren. Die Namen der Pins sollen so benannt werden, wie diese vom Hersteller in den Datenbl�ttern festgelegt ist. Ansonsten k�nnte es Sp�ter Probleme zur Pin-Zuordnung geben \newline Die Schl�sselw�rter \textit{>NAME} und \textit{>VALUE} sollen sich (wenn m�glich) im Symbol befinden. \\
	Package & In dieser Skizze soll eine realit�tsnahe Abbildung des Bauteiles erstellt werden, mit original Abmessungen wie z.B. Platinengr��e, Platinenform, Pins und Bohrl�cher, die aus den jeweiligen Datenbl�ttern ersichtlich sind. 
	Weitere Erg�nzungen sind sonstige Bauteile oder SMD auf einem Device sowie deren Verbindungen auf Ober- bzw. Unterseite. Diese werden derzeit nicht ben�tigt und wurden deshalb weggelassen. \\
	Device & In einem Device werden ein Symbol und ein Package miteinander zusammengef�gt. Die Pins aus dem Symbol und Package Skizzen werden  miteinander verkn�pft. Wenn jeder Pin zugeordnet wurde kann das Device verwendet werden.\\
	\end{tabular}
\end{center}

Der Vorteil dieser Aufteilung ist der, dass einzelne Packages und Symbole f�r mehrere Devices verwendet werden k�nnen. Nur die Anzahl der Pins aus den Packages und Symbolen m�ssen eindeutig �bereinstimmen und zugewiesen werden.

\subparagraph{Um bereits existierende Libaries hinzuzuf�gen} wird die gew�nschte Libary in dem Ordner EAGLE-7.5.0/*lbrName* gespeichert. Anschlie�end klickt man im Reiter \emph{Bibliothek} auf \emph{Benutzen} und w�hlt die gew�nschte Libary aus. Ein Schaltplan muss hierbei ge�ffnet sein. Im \textit{Controll Panel} ist das Hinzuf�gen von libaries nicht m�glich. Zuletzt m�ssen die libaries noch aktualisiert werden( unter \emph{Bibliothek} auf die Rubrik \emph{Alle Aktualisieren}). Abschlie�end auf  \textit{ Add/Neues Bauteil hinzuf�gen}, es erscheint die Libary in der Liste. 

\subparagraph{Um ein vorhandenes Bauteil in die eigene Libary einzuf�gen} muss die Ziel-Libary ge�ffnet sein. Im \textit{Control Panel} von EAEGLE( in der linken Spalte das Men� \textit{Bibliotheken} �ffnen). Hier sollten sich alle bereits hinzugef�gten Libaries befinden. Ist dies nicht der Fall: rechtsklick auf die \textit{Bibliotheken} und  \textit{alle Bibliotheken laden} ausw�hlen. Nun muss die Quell-Libary des Bauteils ge�ffnet werden.Das zu kopierende Bauteil rechts klicken und \textit{In Bibliothek} ausw�hlen. Es ist auch m�glich, einzelne Packages oder Symbole neben ganzen Bauteilen/Devices zu kopieren. Nun sollte das hinzugef�gte Objekt in der Ziel-Libary ge�ffnet sein. Best�tigen sie das Hinzuf�gen mit Speichern der Libary.

\subparagraph{F�r das Bearbeiten existierender Libaries} �ffnen sie eine schematische Skizze. Klicken sie auf \textit{Bibliothek}, dann \textit{�ffnen..} und w�hlen sie die zu �berarbeitende Libary aus. Nun k�nnen alle existierende Bauteile, Packages und Symbole bearbeitet oder neue erstellt werden.
Nach der �nderung speichern Sie die Libary und klicken sie auf wieder auf Bibliothek. Anschlie�end aktualisieren Sie die Libaries. Die �nderungen sollten nun vorgenommen sein.

\textit{Achtung:} �nderungen werden auf alle bestehenden und eingef�gten Elementen vorgenommen. Dies kann sich z.B. unvorteilhaft auf die Lesbarkeit auswirken. Aus diesem Grund sollte zumindest eine Kopie des ge�nderten Devices oder eine neue Version erstellt werden. 

