\chapter{Realisierung}
\label{sec:real}


\paragraph{Der Remoteempf�nger GR-16} hat drei Verbindungen zum Raspberry Pi:
Eine 3,6V bis 8,4V Spannungsversorgung, Ground und eine Datenverbindung.
\phantomsection
\label{Receiver}
\begin{figure}[H]
	\centering
	\includegraphics{fig_motor/GR-16.png}
	\caption[GR-16 Verkabelung]{GR-16 Verkabelung\protect\footnotemark}
\end{figure}
\footnotetext{http://www.graupner.de/mediaroot/files/33508\_Kurzanleitung\_de.pdf}
Die Spannung und Ground kann direkt �ber das Raspberry Pi bezogen werden. F�r die Daten muss einer der GPIO Pins als Input deklariert werden.

Um die Fernbedienung mx-20 mit dem Empf�nger GR-16 zu verbinden m�ssen beide Ger�te eingeschaltet sein (Empf�nger LED blinkt Rot). Beim Anschalten der Fernbedienung wird gefragt ob \emph{HF} EIN oder AUS ist. Stellen Sie auf AUS und best�tigen Sie mit Dr�cken der Set-Taste. Dr�cken sie erneut Set um in die Einstellungen zu gelangen. Scrollen Sie sich mit den Pfeiltasten durch das Men� bis Sie das Men� \emph{Grundeinstellungen Mod.} sehen. �ffnen Sie mit Set das Men� und scrollen Sie durch bis zu Punkt \emph{Modul}. Best�tigen Sie noch NICHT mit der Set-Taste. 
Halten Sie nun am Empf�nger solange die Set Taste gedr�ckt, bis sich zur der roten LED noch eine gr�ne LED einschaltet. Bet�tigen Sie jetzt den Set-Taster auf der Fernbedienung. Es sollte der Info-Text \emph{Binden ...} angezeigt werden.
Wenn die Verbindung erfolgreich durchgef�hrt wurde leuchtet die LED dauerhaft gr�n. \cite{doc:gt-16}

\newpage

\newpage
\section{Umstellung auf eine automatische dynamische Testumgebung}


Stattdessen soll die neue Main-Funktion �ber eine Dauerschleife verf�gen, in dieser ein Textfile ausgelesen wird. Dieses File beinhaltet die zu startenden Testcases des Programmes.

In diesem Textfile werden alle Testf�lle festgehalten, mit einem Status ob dieser laufen soll oder nicht. Der Status soll w�hrend der Laufzeit des Programmes �nderbar sein und dieses auch nicht unterbrechen.

Dieses Textfile sieht folgenderma�en aus:

...\\
testmotorpwm=1\\
testmotorisr=1\\
testmotortxt=0\\
....\\

Dies bedeutet: die Testf�lle testmotorpwm und testmotorisr sollen gestartet werden, testmotortxt soll nicht gestartet werden.
Der Testfall testmotorpwm wird zuerst ausgelesen und von der Main-Funktion auf Null zur�ckgesetzt. Anschlie�end l�uft der Testfall ab.

W�hrenddessen wird der Testfall testmotortxt aktiviert. 

...\\
testmotorpwm=0\\
testmotorisr=1\\
testmotortxt=1\\
....

Ist der Testfall beendet wird das Textfile erneut eingelesen und der n�chste gesetzte Testfall wird gestartet.

\newpage
\paragraph{Umstrukturierung der main.c:}

Es wurde eine Endlosschleife eingef�gt. Statt auf eine Tastatureingabe �ber eine Konsole zu warten, wird in dieser alle zwei Sekunden das \textit{\_Testfile} ausgelesen und �berpr�ft, ob ein Testfall ausgef�hrt werden soll.

In allen Testf�llen darf keine Endlosschleife vorhanden sein, bzw. muss in weiteren Endlosschleifen ein Abbruchkriterium festgelegt sein. In den meisten F�llen kann der Testfall mit Dr�cken der Taste \textit{p} abgebrochen werden. In Testf�llen, in denen ein Testfile ausgelesen wird, wird bei Erreichen des Dateiendes der Testfall beendet und gelangt so wieder in die Hauptschleife zur�ck.

\paragraph{Script zum Setzen der Testf�lle:}

Zum Setzen oder L�schen eines Testfiles wurde ein Script geschrieben, welches auf das textfile \textit{\_Testfile} zugreift und die Eintr�ge je nach Eingabe �berarbeitet.

Verwendet wird das Script folgenderma�en:

\begin{lstlisting}[language=bash]
.\testcase NameTestfall [Modus]
\end{lstlisting}
 	 
Als ersten Parameter ist der zu �berarbeitende Testfall anzugeben.\\
Der Modus ist ein optionaler Parameter. Ist dieser Parameter nicht vorhanden, wird automatisch \emph{set} angenommen. \textit{set} markiert den Testfall als abzuarbeiten, \textit{clear} l�scht diese Markierung wiederrum. Das Script zeigt keinen Fehler oder Warnung auf, wenn der testcase nicht gelistet ist.

Der Quellcode ist im Kapitel \ref{script_testcase} \nameref{script_testcase} auf S.\pageref{script_testcase} einzusehen.


\section{Software Motortreiber}

Es soll Software f�r den Hardware-Treiber, der die Motoren ansteuert, geschrieben werden. Zun�chst muss der Raspberry Pi mit dem I2C-Bus verbunden werden. 
Die I2C Adressen der Motoren sind in der Motor.h hinterlegt. F�r die Quadrocopter wurden die Werte definiert. Die Werte des Octocopter m�ssen zun�chst �berpr�ft werden.

Mittels des Befehl:

Die Daten, die von dem Hardware Brushless-Controller erwartet werden, besitzen folgendes Format:

	\begin{table}[H]
		\centering
		\begin{tabular}{|c|c|}
			\hline
			I2C Adresse [1 Byte] & PWM Value [1 Byte]\\ \hline
		\end{tabular}
	\caption{I2C Frame Brushless Motoren Treiber}
	\end{table}

Mit Hilfe des Befehls 

\begin{center}
	i2cset -y 1 0x29 0x55
\end{center}

wird an den Controller mit der I2C Adresse 0x29 ( Motor Nr.1) der Wert 0x55 gesendet.

\subsection{Verwendung des Software-Treibers}

In der main.h muss zun�chst definiert werden, auf welchem Typ von den HElicoptern das Programm geladen werden soll.
\begin{lstlisting}[language=C++]
#include <time.h>
#define Quadro_Plus 1
//#define Quadro_X 1
//#define Okto_Plus 1
\end{lstlisting}

Anschlie�end sollte baldm�glichst die InitMotor() aufgerufen werden, die unter anderem einen Timer initialisiert und startet. Bei Ablauf des Timers wird ein Flag gesetzt. Dieses Flag muss im Quellcode mit der Funktion \emph{GetFlagRunSendPwmToMotor()} abgefragt werden. Wenn dieses Flag gesetzt ist, muss die Funktion \emph{sendPwmToMotor()} aufgerufen werden.

\begin{lstlisting}[language=C++]
...
InitMotor();
...
while(1){
...
if(GetFlagRunSendPwmToMotor() == 1){
sendPwmToMotor();
}
...

}
\end{lstlisting}
Der aktuelle PWM-Wert eines Motors kann mittels der Funktion \emph{GetPwmMotor(...)} zur�ckgegeben werden.

\begin{lstlisting}[language=C++]
value = GetPwmMotor(6);
value > 0? value--: (value=DEFMotorSetpointMIN);
SetPwmMotor(DEFMotorNo7_PWM, value ,0);
\end{lstlisting}

Wichtig: Alle ISR sollen knapp gehalten werden, da ansonsten die Motoren nicht mehr angesprochen werden k�nnen.

Mit der Funktion \emph{SetPwmMotor(...)} k�nnen die PWM-Werte, die  per I2C gesendet werden, �berschrieben werden. Optional kann ein Flag gesetzt werden. Ist dies der Fall wird anschlie�end die Funktion \emph{sendPwmToMotor()} aufgerufen.

\subsection{Headerfile}

Hier sind die verschiedenen HElicopter Varianten sowie deren definierte Eigenschaften (Anzahl Motoren, Drehrichtung der Motoren, Motorenreihenfogen) festgehalten.

F�r weitere Informationen (wie z.B. Namen der defines) siehe in Kapitel \ref{motorH} in  \nameref{motorH} auf S.\pageref{motorH} .

\subsection{Funktionen}

Beschreibung der Funktionen befinden sich in den jeweiligen dar�ber liegenden Kommentaren mit Parametern und Return Values.

Auf alle globalen Variablen/Flags werden mit Funktionen zugegriffen. Ein direkter Zugriff ist zu vermeiden.


\subsection{Testf�lle}

Um die Funktionalit�t des Treiber zu testen und kontrollieren sind die folgenden Testf�lle geschrieben worden. 

\subparagraph{TESTMOTORPWM}

Dieses Testprogramm sendet alle 10ms an die Motoren einen stets steigenden PWM-Wert bis zum Wert 0x50. Bei erreichen des Wertes wird der PWM-Wert auf den definiertes Minimum gesetzt. Dieser Testfall l�uft ohne ISR ab. Die Daten werden direkt �ber I2C gesendet. Die Schrittweite und das Maximum des Testfalles sind per Konstanten definiert und k�nnen ver�ndert werden. 

\subparagraph{TESTMOTORISR}

Mit diesem Testprogramm wird die ISR-Funktion getestet. Durch Eingabe in der Konsole wie z.B.

+0+0+0+0+7+7+7-8

wird der  PWM-Wert des Motors 0 um vier erh�ht, der Motor 7 um drei erh�ht und der Motor 8 um eins verringert. Die Eingabe ist nicht blockierend. Zum Starten des Testfalls muss ein '+' eingetippt werden.

\subparagraph{TESTMOTORTXT}

Der letzte Testfall liest aus einem Textfile, das sich auf dem Raspberry unter dem Pfad \emph{/home/pi/MotorTest.txt} befinden muss, Zeile f�r Zeile aus und setzt die PWM-Werte so, wie sie in der Zeile angegeben sind.

Die Befehlszeile hat folgendes Format:
\newline
\begin{center}
\#MOTORNUMER[+][-][=][PWMWERT]\;DELAY
\end{center}
z.B.
\#0+100;10 \t - \t Der PWM des Motors 0 erh�ht sich um 100. Die n�chste Zeile wird in 10s eingelesen.

\newpage
\section{Remotecontroller-Treiber}
\label{Controller Treiber}

Um den autonomen Start bzw. Landevorgang des Quadrocopter einzuleiten muss eine Funkverbindung �ber eine Fernbedienung und einen Transmitter eingerichtet werden. Die Daten sind anschlie�end auszuwerten und zu verarbeiten.

Als Fernbedienung von der Firma Graupner dient der \emph{MX-20} und als Receiver der \emph{GR-16}. Der Anschluss des Receivers erfolgt �ber drei Leitungen:
\begin{itemize} 
	\item  Versorgungsspannung:  5Volt (vom Raspberry) 
	\item  Ground (Raspberry)
	\item PPM (Puls-Pause Modulation) (auf einen der GPIO Pins)
\end{itemize}


\paragraph{Verbinden mit Receiver}
Schalten Sie die Fernbedienung ein und schlie�en den Receiver an den Raspberry Pi an [siehe Abschnitt~ \ref{Receiver} auf Seite \pageref{Receiver}]

\paragraph{PPM-Signal} genannt Puls-Pausen-Modulation (oder auch Puls-Position-Modulation) ist ein f�r analoge Werte verwendetes Kodierungsverfahren und wird vor allem in Funkfernsteuerungen verwendet. Der zu kodierende Wert wird in der L�nge des Pausen/Low Signals zwischen zwei Peaks/High Signalen gesendet. Diese Peaks haben stets die gleiche L�nge als auch gleiche Amplitude.\cite{doc:ppm}

Meist besteht ein PPM-Signal aus mehreren Kan�len zu einem Frame zusammengef�gt und  anschlie�end versendet.

F�r die Decodierung des PPM-Signals ist es empfehlen, ein weiteres Board zu integrieren, das die Decodierung  �bernimmt und die Ergebnisse an das Raspberry Pi weiterleitet, da das Signal sehr genau aufgel�st werden muss und die Decodierung �ber einen Interrupt gesteuert werden soll. Bei zu h�ufigen Auftreten des Interrupts w�rde der Helicopter destabilisiert werden. Zur Auswertung m�ssen nur die Raising Edges oder Falling Edges beachtet und der Offset des High-Pegels abgezogen werden.

Um auf ein weiteres Bauteil zu verzichten wurde stattdessen eine Real-Time-Linux-Version auf dem Raspberry Pi installiert, die die Signale im Nanosekundenbereich dekodieren kann.

\newpage
\paragraph{PPM Signal Mitschnitte}
Der Receiver sendet die empfangenen Signale im Format der Pulse-Pausen-Modulation. Mitgeschnittene �bertragungen\protect\footnotemark  mit Beschreibung sind beigef�gt.
\footnotetext{Von Herrn Trybek bereitgestellt}
\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\textwidth]{fig_motor/Controller_Treiber/GraupnerGR16_8_Frame.png}
	\caption[8 Channel Frame]{8 Channel Frame}
\end{figure}

Es gibt zwei M�glichkeiten: ein Frame mit acht Kan�len, bestehend aus neun Peaks und acht Pausensignalen...

\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\textwidth]{fig_motor/Controller_Treiber/GraupnerGR16_12_Frame.png}
	\caption[12 Channel Frame]{12 Channel Frame}
\end{figure}

... oder einen 12 Kan�len Frame, bestehend aus 13 Peaks und 12 Pausensignalen.

\begin{figure}[H]
\centering
\includegraphics[width=0.6\textwidth]{fig_motor/Controller_Treiber/GraupnerGR16_8_ChX_Gap.png}
\caption[Dauer 8 chanel Frame ]{Dauer 8 Chanel Frame}
\end{figure}

Folgend die Anschaung eines Frames mit acht Kan�len mit der Dauer von 504us.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\textwidth]{fig_motor/Controller_Treiber/GraupnerGR16_8_Ch1_Min.png}
	\caption[Minimale Pause zwischen Frames]{Minimale Pause zwischen Frames}
\end{figure}

Zu sehen ist hier der kleinstm�gliche zeitliche Abstand zwischen zwei Frames mit der Dauer von nur 504us.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\textwidth]{fig_motor/Controller_Treiber/GraupnerGR16_8_Ch1_Max.png}
	\caption[Maximale Pause zwischen Frames]{Maximale Pause zwischen Frames}
\end{figure}

Hier ein Ausschnitt mit dem gr��tm�glichen Abstand zwischen zwei Frames mit der Dauer 1,396ms.

\section{Hardware Layout}
F�r die schnelle Durchf�hrung von �nderungen, Erweiterungen oder Anpassungen an der Hardware werden die Leiterplatinen und Schaltpl�ne mittels Tool elektronisch festgehalten. Die dazu m�gliche Software sind: EAGLE oder Fritzing,
die kostenlos oder als eingeschr�nkte Freeversion angeboten werden, aber diversen Einschr�nkungen unterliegen. Beide Tools haben eine Community, die viele Bauteile in Liberias bereitstellt. 

Im direktem Vergleich macht EAGLE einen professionelleren Eindruck und bietet eine Sammlung von Tutorials und Libraries. Aus diesen Gr�nden fiel die Entscheidung auf die EAGLE SOFTWARE. Es sollte aber mit dem Platz m�glichst sparend umgegangen werden, da bei dieser Freeeware die Gr��e und Anzahl der Layouts begrenzt ist.

\subsection{HElicopter Schematic Layout}

Es wurde f�r die schematischen Zeichnungen ein EAGLE Projekt angelegt, dass die schematischen Zeichnungen aller selbst gebauten bzw. zusammengef�gten Bauteile enth�lt. Das Projekt File ist im Verzeichnis \textit{trunk/hardware/} unter \textit{HElicopterPlus} abgespeichert.

Derzeit befinden sich zwei verschiedene schematischen Zeichnungen im Projektverzeichnis, die maximal aus zwei sogenannten Sheets besteht (Begrenzung durch die Freeware-Version von EAGLE). Der erster Sheet beinhaltet immer, denn Komplettaufbau des jeweiligen Systems. Der zweite Sheet wird verwendet um druckbare Versionen das Schaltplans zu erstellen (DINA4 Frame). Hierbei ist es wichtig, eine �bersichtliche Abspaltung vorzunehmen. 


\newpage
\includepdf[landscape=true,pages={1,2}]{fig_motor/Schematic/SchematicKomplettPrintVersion.pdf}
\includepdf[landscape=true]{fig_motor/Schematic/SchematicLedDriver.pdf}

\subsubsection{Richtlinien\cite{doc:guidelinesSchematics}}

\begin{itemize}
	\item Platzierung von mindestens einem Frame in jedem Sheet
	\item Verwendung von "Common" Symbolen
	\item Jedem Bauteil einen Wert zuordnen (wenn m�glich)
	\item F�r Verbindungen ausschlie�lich \textit{Net} verwenden ( nicht \textit{Wire})
	\item Verbindungen oder �berbr�ckungen wie in Abb. \ref{CrossingConnection} dargestellt
	\item Abk�rzungen direkt in dem jeweiligen Sheet festhalten
	\item Name und Bauteile immer in eine Richtung flie�en lassen (wenn m�glich)
	\item �berbr�cken von Netzen m�glichst gering halten
	\item F�r gro�e schematische Skizzen immer auch druckbare Versionen in DINA4 Format erstellen
	\item Wichtigen Netzen immer einen Namen zuordnen (GND, +5V, SDA, SLC, ...)
	\item Namen und Bezeichnungen kurz halten
\end{itemize}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\textwidth]{fig_motor/Schematic/CrossingConnection.jpg}
	\caption[Net verbinden/�berbr�cken]{Net verbinden/�berbr�cken\protect\footnotemark}
	\label{CrossingConnection}
\end{figure}
\footnotetext{\url{http://www.k-state.edu/ksuedl/publications/Technote\%208\%20-\%20Guidelines\%20for\%20Drawing\%20Schematics.pdf}}


\newpage
\subsection{HElicopter Libary}
Auf der Bibliothek von Eagles k�nnen unter der Rubrik \emph{Downloads} Bauteile zu denn Schaltpl�nen gefunden werden. Die dort vorhandenen Bibliotheken sind von Usern bereitgestellt worden. Deshalb besteht die M�glichkeit, dass Bauteile fehlerhaft sind.

Wenn in der Bibliothek kein Element f�r das Bauteil gefunden werden konnte, muss dieses erstellt und in der bereits vorhandene Libary \textit{HElicopterLib.lbr} hinzugef�gt werden. In dieser Libary sind alle Teile festgehalten, die f�r die Quadrocopter ben�tigt werden. 

Ein Bauteil oder auch ein Device besteht aus insgesamt drei eigenen Bestandteilen, die alle vorhanden sein m�ssen, um das Bauteil zu verwenden:
\begin{center}
	\begin{tabular}{l p{10 cm} }
	Symbol & Darunter versteht man eine schematische Skizze eines Bauteils. Alle Schnittstellen des Bauteiles sind zu erkennen und ggf. zu kennzeichen. \newline Der Orignalma�stab und Echtheit der Pinanordnung spielt keine Rolle. Diese soll m�glichst so platziert werden, um im sp�teren Layout eine gewisse �bersichtlichkeit zu wahren. Die Namen der Pins sollen so benannt werden, wie diese vom Hersteller in den Datenbl�ttern festgelegt ist. Ansonsten k�nnte es Sp�ter Probleme zur Pin-Zuordnung geben \newline Die Schl�sselw�rter \textit{>NAME} und \textit{>VALUE} sollen sich (wenn m�glich) im Symbol befinden. \\
	Package & In dieser Skizze soll eine realit�tsnahe Abbildung des Bauteiles erstellt werden, mit original Abmessungen wie z.B. Platinengr��e, Platinenform, Pins und Bohrl�cher, die aus den jeweiligen Datenbl�ttern ersichtlich sind. 
	Weitere Erg�nzungen sind sonstige Bauteile oder SMD auf einem Device sowie deren Verbindungen auf Ober- bzw. Unterseite. Diese werden derzeit nicht ben�tigt und wurden deshalb weggelassen. \\
	Device & In einem Device werden ein Symbol und ein Package miteinander zusammengef�gt. Die Pins aus dem Symbol und Package Skizzen werden  miteinander verkn�pft. Wenn jeder Pin zugeordnet wurde kann das Device verwendet werden.\\
	\end{tabular}
\end{center}

Der Vorteil dieser Aufteilung ist der, dass einzelne Packages und Symbole f�r mehrere Devices verwendet werden k�nnen. Nur die Anzahl der Pins aus den Packages und Symbolen m�ssen eindeutig �bereinstimmen und zugewiesen werden.

\subparagraph{Um bereits existierende Libaries hinzuzuf�gen} wird die gew�nschte Libary in dem Ordner EAGLE-7.5.0/*lbrName* gespeichert. Anschlie�end klickt man im Reiter \emph{Bibliothek} auf \emph{Benutzen} und w�hlt die gew�nschte Libary aus. Ein Schaltplan muss hierbei ge�ffnet sein. Im \textit{Controll Panel} ist das Hinzuf�gen von libaries nicht m�glich. Zuletzt m�ssen die libaries noch aktualisiert werden( unter \emph{Bibliothek} auf die Rubrik \emph{Alle Aktualisieren}). Abschlie�end auf  \textit{ Add/Neues Bauteil hinzuf�gen}, es erscheint die Libary in der Liste. 

\subparagraph{Um ein vorhandenes Bauteil in die eigene Libary einzuf�gen} muss die Ziel-Libary ge�ffnet sein. Im \textit{Control Panel} von EAEGLE( in der linken Spalte das Men� \textit{Bibliotheken} �ffnen). Hier sollten sich alle bereits hinzugef�gten Libaries befinden. Ist dies nicht der Fall: rechtsklick auf die \textit{Bibliotheken} und  \textit{alle Bibliotheken laden} ausw�hlen. Nun muss die Quell-Libary des Bauteils ge�ffnet werden.Das zu kopierende Bauteil rechts klicken und \textit{In Bibliothek} ausw�hlen. Es ist auch m�glich, einzelne Packages oder Symbole neben ganzen Bauteilen/Devices zu kopieren. Nun sollte das hinzugef�gte Objekt in der Ziel-Libary ge�ffnet sein. Best�tigen sie das Hinzuf�gen mit Speichern der Libary.

\subparagraph{F�r das Bearbeiten existierender Libaries} �ffnen sie eine schematische Skizze. Klicken sie auf \textit{Bibliothek}, dann \textit{�ffnen..} und w�hlen sie die zu �berarbeitende Libary aus. Nun k�nnen alle existierende Bauteile, Packages und Symbole bearbeitet oder neue erstellt werden.
Nach der �nderung speichern Sie die Libary und klicken sie auf wieder auf Bibliothek. Anschlie�end aktualisieren Sie die Libaries. Die �nderungen sollten nun vorgenommen sein.

\textit{Achtung:} �nderungen werden auf alle bestehenden und eingef�gten Elementen vorgenommen. Dies kann sich z.B. unvorteilhaft auf die Lesbarkeit auswirken. Aus diesem Grund sollte zumindest eine Kopie des ge�nderten Devices oder eine neue Version erstellt werden. 

