%--------------------------------------------
% Chapter: REMOTE CONTROL UNIT: GRAUPNER PPM DECODING
%--------------------------------------------
\chapter{Remote Control Unit: PPM Decoding}
\label{sec:remoteControl}

%- - - - - - - - - - - - - - - - - - - - - - 
% Section: Graupner PPM Signal in a nutshell
%- - - - - - - - - - - - - - - - - - - - - - 
\section{Graupner PPM sum signal in a nutshell}
\label{sec:remoteControl:ppmNutshell}



\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{fig/ch-ppm-kernel-driver/graupnerPWM}
    \caption[PWM signal scheme of a RC servo \cite{doc:RPL}]{PWM signal to control a RC servo \cite{doc:RPL}}
    \label{fig:remoteControl:ppmNutshell:pwmSignal}
\end{figure}



\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{fig/ch-ppm-kernel-driver/graupnerPPM}
    \caption[PPM sum signal scheme \cite{doc:REP}]{PPM sum signal scheme of an exemplary 6 channel remote control \cite{doc:REP}}
    \label{fig:remoteControl:ppmNutshell:ppmSumSignal}
\end{figure}

In line 11 of listing \ref{code:remoteControl:kernModule:makefile} the object file (with file extension \texttt{.o}) of the compilation process that shall be linked as a kernel module file (file extension \texttt{.ko}) gets defined. If another kernel driver file shall be compiled, put the c-code file name there and change the file extension to \texttt{.o}.

\begin{lstlisting}[language=bash,caption={[Simple Makefile to compile a custom kernel driver]Simple Makefile to compile a custom kernel driver (here for the kernel module \texttt{ppmDemux})},label=code:remoteControl:kernModule:makefile,otherkeywords={ifeq,else,ifneq,endif,default,clean}]
\end{lstlisting}
In the case of the \texttt{ppmDemux} kernel driver, a free running 64bit counter (called \texttt{System Timer}\footnote{See the peripherals datasheet on Raspberry Pi's SoC \href{https://www.raspberrypi.org/documentation/hardware/raspberrypi/bcm2835/BCM2835-ARM-Peripherals.pdf}{Broadcom BCM2835}, p. 172 ll. }) of the Raspberry Pi's System on Chip (SoC) has been used to determine a precise timing. This free running counter runs on $1Mhz$ independently of all other peripherals. This results in a maximum accuracy of $1\mu s$ of all measurements that utilize the \texttt{System Timer}.

The hardware address of the \texttt{System Timer} is defined by the base address \texttt{0x7E003000} plus the offset of the required data register (see \cite{doc:bcm2835}, p. 175 ll.). Due to the \texttt{MMU} of the BCM2835 chip, the physical hardware address gets translated to the I/O base address \texttt{0x20003000} (as defined in line 27 of listing \ref{code:append-ppmDemuxCode:ppmDemux}). This address has to be used in the kernel module driver to access the free running $1Mhz$ \texttt{System Timer}.

Based on the articles \cite{doc:Kern70} and \cite{doc:Kern81}, a kernel driver has been developed, to process a hardware trigger on GPIO pin 24. Whenever a rising edge is detected, a hardware interrupt is issued to the Kernel. The interrupt behavior in rising edges is defined in line 96 of listing \ref{code:append-ppmDemuxCode:ppmDemux}. The Interrupt Service Routine (ISR) is called in consequence (defined as function \texttt{hard\_isr} in line 60 ll. of listing \ref{code:append-ppmDemuxCode:ppmDemux}). 
\begin{lstlisting}[firstnumber=60]
static irqreturn_t hard_isr( int irq, void *dev_id )
{
	/* read free running timer (64bit) @ 1MHz */
	modIrqObj.timer_l = readl(timer_low);
	modIrqObj.timer_h = readl(timer_high);

	/* counts rising edges since last read */
	modIrqObj.irqNum += 1;

	return IRQ_WAKE_THREAD;
}
\end{lstlisting}
This Interrupt Service Routine is the first function called whenever a rising edge event on GPIO24 occurs. The value of the 64bit \texttt{System Timer} get read out and an interrupt counter gets increased. That way, even for the unprobable case that one interrupt gets unprocessed, the synchronization of the Graupner PPM sum signal can be guaranteed.

After the hard ISR\footnote{Code inside of the hard ISR should be reduced to the absolute minimum and only necessary tasks should be performed. Every unnecessary CPU cycle in this section will slow down the system performance dramatically!} has been processed, the threaded interrupt handler \texttt{rpi\_gpio\_isr} (line 52 ll. of listing \ref{code:append-ppmDemuxCode:ppmDemux}) gets called. For complex kernel drivers, in this function can be implemented complex algorithms to process the captured signals. This function is threaded and can be prioritized by the kernel's scheduler to guarantee a minimal latency time of the system.
\begin{lstlisting}[firstnumber=60]
static irqreturn_t hard_isr( int irq, void *dev_id )
{
	/* read free running timer (64bit) @ 1MHz */
	modIrqObj.timer_l = readl(timer_low);
	modIrqObj.timer_h = readl(timer_high);

	/* counts rising edges since last read */
	modIrqObj.irqNum += 1;

	return IRQ_WAKE_THREAD;
}
\end{lstlisting}
When all statements of the soft (threaded) ISR \texttt{rpi\_gpio\_isr} has been processed, the read function of the kernel driver get waken up (see listing \ref{code:append-ppmDemuxCode:ppmDemux} in line 55 and line 118 for the counterpart in the read function).
\begin{lstlisting}[firstnumber=52]
static irqreturn_t rpi_gpio_isr( int irq, void *data )
{
	/* wake up read function to retrieve new data */
	wake_up( &sleeping_for_ir );
\end{lstlisting}
\vspace{-0.7cm}
\begin{lstlisting}[firstnumber=117]
	/* wait for an rising edge event (caught by ISR) */
	wait_event_interruptible( sleeping_for_ir, modIrqObj.irqNum);
\end{lstlisting}


After the file transfer is finished, the kernel module can be loaded to the Linux System. Navigate to the location of the stored kernel module object file (in this example the home directory of the user \texttt{pi}) and use the command \texttt{insmod}.
\begin{lstlisting}[language=bash,otherkeywords={insmod, sudo}]
cd /home/pi/
sudo insmod ppmDemux.ko
\end{lstlisting}

If the kernel module is successfully loaded (no error messages occurred), then a character file handler \texttt{/dev/gpioirq24} has been created by the kernel module driver \texttt{ppmDemux}. Get noticed of rising edges on GPIO pin 24, read the character file handler \texttt{/dev/gpioirq24} as shown in the exemplary test code

%- - - - - - - - - - - - - - - - - - - - - - 
% Section: Stimulating the GPIO-Pins
%- - - - - - - - - - - - - - - - - - - - - - 
\section{Stimulating the GPIO-Pins for validation}
\label{sec:remoteControl:stimuli}

For testing and validation purposes of the custom built Kernel Driver \texttt{ppmDemux} of chapter \ref{sec:remoteControl:kernModule}, it was required to stimulate the GPIO pin 24 with a PPM signal similar to a Graupner sum signal.

For this purpose, a STM32F4 Discovery board was used to run a specifically written firmware that produces a variable PPM signal as depicted in fig. \ref{fig:remoteControl:stimuli:hwSetup}. The firmware of the STM32F4 board is capable to produce PPM signals with a pulse-to-pulse with of $480\mu s$ up to $2560\mu s$. By pressing the \texttt{blue button} of the STM32F4 Discovery board as shown in fig. \ref{fig:remoteControl:stimuli:hwSetup}, the pulse-to-pulse width can be altered in the sequence as shown on table \ref{tab:remoteControl:stimuli:stm32f4States}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.80\textwidth]{fig/ch-ppm-kernel-driver/picStimulusRpi}
    \caption[Stimulating GPIO Pins of Raspberry Pi]{In order to test the PPM kernel driver, a STM32F4 Discovery Board was used to stimulate the GPIO Pin 24 of Raspberry Pi Board. The signals got also observed by a 50 MHz Oscilloscope to validate the measured PPM length.}
    \label{fig:remoteControl:stimuli:hwSetup}
\end{figure}

To use the firmware, first the CooCox IDE\footnote{http://www.coocox.org/software/coide.php} has to be installed on the development machine as well as the GCC Toolchain for ARM Embedded Processors\footnote{https://launchpad.net/gcc-arm-embedded/+download}

\begin{table}[H]
\centering
	\begin{tabular}{c|c||c|c}
\hline
\textbf{State No.} & \textbf{Pulse-to-pulse witdth} & \textbf{State No.} & \textbf{Pulse-to-pulse witdth}\\
\hhline{=|=#=|=}
1 & $480\mu s$ & 10 & $1590\mu s$\\
2 & $620\mu s$ & 11 & $1710\mu s$\\
3 & $730\mu s$ & 12 & $1840\mu s$\\
4 & $860\mu s$ & 13 & $1960\mu s$\\
5 & $970\mu s$ & 14 & $2080\mu s$\\
6 & $1100\mu s$ & 15 & $2200\mu s$\\
7 & $1220\mu s$ & 16 & $2320\mu s$\\
8 & $1350\mu s$ & 17 & $2440\mu s$\\
9 & $1460\mu s$ & 18 & $2560\mu s$\\
\hline
	\end{tabular}
	\caption[Pulse-to-pulse width of STM32F4 firmware states]{Pulse-to-pulse width in microseconds for each state of the STM32F4 firmware}
	\label{tab:remoteControl:stimuli:stm32f4States}
\end{table}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.60\textwidth]{fig/ch-ppm-kernel-driver/osci_ppm_610us}
    \caption[Oscilloscope graph of stimulus signal (610µs)]{Oscilloscope graph of stimulus signal emitted by the STM32F4 Discovery board (Custom STM32F4 firmware for 610$\mu$s pulse-to-pulse width).}
    \label{fig:remoteControl:stimuli:oszi610}
\end{figure}

To validate the stimulus signal output of the STM32F4 Discovery board, the output signals where observed with a 50Mhz oscilloscope. Screenshots of two PPM signals are shown in fig. \ref{fig:remoteControl:stimuli:oszi610} and fig. \ref{fig:remoteControl:stimuli:oszi1220}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.60\textwidth]{fig/ch-ppm-kernel-driver/osci_ppm_1220us}
    \caption[Oscilloscope graph of stimulus signal (1220$\mu$s)]{Oscilloscope graph of stimulus signal emitted by the STM32F4 Discovery board (Custom STM32F4 firmware for 1220$\mu$s pulse-to-pulse width).}
    \label{fig:remoteControl:stimuli:oszi1220}
\end{figure}

%- - - - - - - - - - - - - - - - - - - - - - 
% Section: Results on experimental kernel driver
%- - - - - - - - - - - - - - - - - - - - - - 
\section{Results on experimental kernel driver}
\label{sec:remoteControl:results}

Before the custom kernel module driver \texttt{ppmDemux} has been developed by the authors of this document, a performance test of the standard Kernel's GPIO interface has been evaluated. For this purpose, a $1220\mu s$ PPM signal was generated (as shown in chapter \ref{sec:remoteControl:stimuli}) and measured with a simple test script.

The measured pulse-to-pulse time was measured under system idle and system under full load. The 'system under full load' scenario was produced by executing 3 threads that run at full load as well as 3 threads that produce full I/O-load. To achieve this, the program \texttt{stress} was installed on the Raspberry Pi's Linux system by issuing the command shown below on the Raspberry Pi's bash command line
\begin{lstlisting}[language=bash,otherkeywords={sudo,tar,touch,gedit,cp,apt-get,mkdir}]
sudo apt-get install stress
\end{lstlisting}

To set the test system under a full load scenario, the command \texttt{stress} got issued as shown below:
\begin{lstlisting}[language=bash,otherkeywords={sudo,tar,touch,gedit,cp,apt-get,mkdir}]
sudo stress -c 3 -i 3 &
\end{lstlisting}
This command starts 3 threads that each consume the max. CPU cycles available\footnote{The ampersand character (\texttt{\&}) at the end of the line runs the processes in the background of the system. To stop the program \texttt{stress} type the command '\texttt{sudo killall stress}' to the bash command line. This will terminate all processes of the program \texttt{stress} and set the system back to an idle state.}. Additonally 3 threads are started that each put a max. I/O load on the system. This setup can be considered as a maximum load scenario for a the single core Raspberry Pi B+ board.

For each scenario (idle and full load), approximately 10000 measurements where taken and stored. In fig. \ref{fig:remoteControl:results:stdKernIdle} and fig. \ref{fig:remoteControl:results:stdKernLoad} the results of these measurements can be seen.

When using the standard Kernel's GPIO interface, the accuracy of the measurement under system idle is still in a acceptable range although latency jitter exceeds the acceptable range in rare cases (compare with fig. \ref{fig:remoteControl:results:stdKernIdle}).

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{fig/ch-ppm-kernel-driver/stdKern_woLoad}
    \caption[Measured pulse period time with standard kernel (system on idle)]{Measured pulse period time with standard kernel's GPIO interface \\(system on idle)}
    \label{fig:remoteControl:results:stdKernIdle}
\end{figure}

On the other hand, when the system is under full load the latency jitter exceeds the acceptable range by far. As in fig. \ref{fig:remoteControl:results:stdKernLoad} can be seen, approximately 25\% of all measured pulse-to-pulse widths are missed. This results in measured pulse-to-pulse width that is double the width of the stimulus signal. The second spike at $2.5ms$ indicates this effect. Unfortunately, for a mechanism to measure the user's remote control input, this is a unacceptable situation.

Therefore, the development of a custom kernel module driver called \texttt{ppmDemux} has been started. The proof-of-concept approach of chapter \ref{sec:remoteControl:kernModule} has been tested under a Preempt\_RT patched Kernel environment, as shown in chapter \ref{sec:OS:preemptRtPatch}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{fig/ch-ppm-kernel-driver/stdKern_withLoad}
    \caption[Measured pulse period time with standard kernel (system under full load)]{Measured pulse period time with standard kernel's GPIO interface (system under full load). The second spike at 2.4ms shows that many rising edges of the stimulus signal are missed. This is a non-acceptable result for a reliable system.}
    \label{fig:remoteControl:results:stdKernLoad}
\end{figure}

The custom kernel driver \texttt{ppmDemux} has been test again under the two test scenarios: system idle and system under full load (using the command \texttt{stress}). Under system idle conditions, fortunately the measured results are very good. The latency is negligible small and the latency jitter has a variance of roughly $10\mu s$ for a stimulus PPM signal with a pulse-to-pulse width of $1220\mu s$ (as shown in fig. \ref{fig:remoteControl:results:customKernIdle}). With some post-processing filters, a measurement accuracy of 1\%-3\% is a very realistic range for a future implementation.

Fortunately, even under heavy system load (full load scenario), the latency is again negligible. Also the latency jitter rises only marginally. A variance of not more than $53\mu s$ for a stimulus PPM signal under full load can be assumed (as depicted in fig. \ref{fig:remoteControl:results:customKernLoad}). No single edge of the PPM signal has been missed. Since the measurement shows a robust and reliable measurement behavior of the custom kernel driver, this approach is considered to be acceptable for the high reliability requirements of this project.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.71\textwidth]{fig/ch-ppm-kernel-driver/customKern_woLoad}
    \caption[Measured pulse period time with \texttt{ppmDemux} (system on idle)]{Measured pulse period time with \texttt{ppmDemux} (system on idle). The very low latency jitter shows the superior performance of the kernel driver approach.}
    \label{fig:remoteControl:results:customKernIdle}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.71\textwidth]{fig/ch-ppm-kernel-driver/customKern_withLoad}
    \caption[Measured pulse period time with \texttt{ppmDemux} (system under full load)]{Measured pulse period time with \texttt{ppmDemux} (system under full load). Even under system's full load, the latency jitter is in an acceptable range. No single rising edge of the stimulus signal is missed. This shows that the kernel driver approach is the best choice for the high reliability requirements of this project.}
    \label{fig:remoteControl:results:customKernLoad}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\textwidth]{fig_motor/Controller_Treiber/GraupnerGR16_8_Frame.png}
	\caption[8 Channel Frame]{8 Channel Frame}
\end{figure}


\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\textwidth]{fig_motor/Controller_Treiber/GraupnerGR16_12_Frame.png}
	\caption[12 Channel Frame]{12 Channel Frame}
\end{figure}


\begin{figure}[H]
\centering
\includegraphics[width=0.6\textwidth]{fig_motor/Controller_Treiber/GraupnerGR16_8_ChX_Gap.png}
\caption[Dauer 8 chanel Frame ]{Dauer 8 Chanel Frame}
\end{figure}

Folgend die Anschaung eines Frames mit acht Kan�len mit der Dauer von 504us.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\textwidth]{fig_motor/Controller_Treiber/GraupnerGR16_8_Ch1_Min.png}
	\caption[Minimale Pause zwischen Frames]{Minimale Pause zwischen Frames}
\end{figure}

Zu sehen ist hier der kleinstmögliche zeitliche Abstand zwischen zwei Frames mit der Dauer von nur 504us.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\textwidth]{fig_motor/Controller_Treiber/GraupnerGR16_8_Ch1_Max.png}
	\caption[Maximale Pause zwischen Frames]{Maximale Pause zwischen Frames}
\end{figure}

Hier ein Ausschnitt mit dem größtmöglichen Abstand zwischen zwei Frames mit der Dauer 1,396ms.


